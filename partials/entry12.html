<div class="landing-bg">
<div class="jumbotron">
        <div class="container">
                <h1>The Technical Writing Seminar: REST API and Documentation</h1>
        </div>
</div>
</div>
<div class="container">

<p> Our original REST API contained dummy data that we had made up for development purposes. We began the effort of changing to the real data provided to us by Dining Services. We found that the data did look similar to what we had predicted, but there were some subtle differences that we had to understand-- for instance, they didn't have a uniformly increasing primary key for food entries, nor did they have them for menus. In addition, some data columns had counterintuitive names (like "recipe" for a food item), and others had variable lengths such as ingredient lists. Another problem was that some data was simply incomplete, which caused errors when were doing database migrations. Yet another problem was that some of the values were hard-coded and required outside knowledge to understand what they really meant (such as the ids for dining hall locations).</p>

<p>One by one, we got past these obstacles. We changed our models to mimic the real data and added flexibility such as larger data sizes and relaxed database constraints. We eventually had a succesful data migration, but there was more work to be done. We realized that authentication and access control still needed to be fleshed out more. Even though it was not a requirement for this leg, we felt that it was important enough for our application, so we marched forward. One challenge we faced was the idea of which authentication scheme to use. Basic authentication was simplest but required encryption because the password will be sent in plain text as a header. Given that Heroku provides support for SSL, we ultimately decided that was good enough (and much easier to implement than Session/Token authentication).</p>

<p>Another challenge was picking which authorization level to have on by default. One option was to authenticate everything, but that was quite restrictive bcause it didn't allow us to easily override that behavior within our helper methods, since the client would automatically be prevented from accessing that method in the first place. At the same time, it would've been tedious (and potentially dangerous) to allow all requests to go through and have to override that permission everywhere we wanted to. Ultimately, we decided to go with IsAuthenticatedOrReadOnly, which was a nice compromise between the two. We also made some key decisions such as not allowing PUT/PATCH on Consumption objects, because that's something where the user doesn't ever need to update it-- you either consume a specific food (POST), or you can just remove the consumption of that specific food (DELETE).</p>

<p>Once we got the actual behaviors we wanted, it was time to document it all. We read about Swagger as a good tool for documenting REST APIs, and indeed there was a lot of "magic" that we got right out of the gate. The interface looked good, but the problem was that customizing it was very difficult. Django Rest Swagger makes a lot of assumptions about how you have annotated your code, and it can only use those annotations to generate its documentation. It was a lot of guesswork to figure out where these comments had to go, since Swagger itself didn't describe where it's pulling its data from. Eventually, we figured out that Django Rest Swagger relies heavily on your Serializer fields (and its associated metadata) to generate its schema, and so we were able to leverage that to generate our documentation. Our latest API lives at https://yumborestapi.herokuapp.com.</p>

<p>We're still facing some challenges in production. First is that our static files cannot be served when debug is set to false in our settings. We've read that this has something to do with how Heroku file permissions work, and it seems that Debug mode = True accounts for that effect. We're still figuring out how to make it work with Debug turned off (it seems that whitenoise is a package which may help with static file serving). Our second issue is that we don't have enough rows in Heroku for all our data. For now, we've limited our dataset to very recent dining data, but we ultimately would like our users to log historical food consumption too. Finally, our basic authentication scheme relies on having a secure connection, but our application is still accessible via plain HTTP right now (it's accessible via HTTPS as well, but it's not forced right now.) We're hoping to do a forced redirect to HTTPS. </p> 


</div>