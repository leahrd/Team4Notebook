<div class="landing-bg">
<div class="jumbotron">
        <div class="container">
                <h1>2: Exploring Your Options</h1>
                <p class="lead">February 9, 2017</p>
        </div>
</div>
</div>
<div class="container">

        <h1>Web Frameworks</h1>
        <p class="lead">Shawyoun</p>
        <table class="table table-responsive table-striped">
                <tr class="text-center">
                        <th>Name</th>
                        <th>Pros</th>
                        <th>Cons</th>
                </tr>
                <tr>
                        <td>Express (on top of NodeJS)</td>
                        <td>
                                <ul>
                                        <li>Node.js uses JavaScript, which we're familiar with and is used on the frontend as well</li>
                                        <li>npm (Node packaged modules) is a growing set of libraries with an active community (Examples include Mocha.js for unit testing, Grunt.js for automated build tasks, Brackets for full-text code editing)</li>
                                        <li>Node.js is good for I/O intensive applications because it can handle concurrent asynchronous requests</li>
                                        <li>Express is the most mature and stable Node.js framework</li>
                                        <li> Smaller learning curve (more minimalist) than the "batteries included" frameworks like Django and Rails)</li>

                                </ul>
                        </td>
                        <td>
                                <ul>
                                        <li>Node is bad for CPU-intensive applications because JS is single threaded and an operation can block the event loop</li>
                                        <li>In Node, easy to fall into "callback hell" (unreadable code loaded with callbacks) without understanding asynchronous programming well</li>
                                        <li>Express has no built-in error handling</li>
                                        <li>Express has larger footprint compared to other Node.js frameworks (like Koa and Hapi)</li>
                                </ul>
                        </td>
                </tr>
                <tr>
                        <td>Django</td>
                        <td>

                                <ul>
                                        <li>Uses Python, which is generally considered a very readable and straightforward language</li>
                                        <li>Mature and stable ecosystem</li>
                                        <li>Strong admin interface for managing databases (and creating mappings with application objects), and supports wide range of databases</li>
                                        <li>Support for templating and object relational modeling</li>

                                </ul>
                        </td>
                        <td>
                                <ul>
                                        <li>Templating language can be restrictive-- doesn’t allow for Python functions to be called</li>
                                         <li>Things have to be done more explicitly (less "magic" than in Rails)-- for example, auto-incrementing has to be activated by user</li>
                                        </li>Relatively large learning curve because it comes with so much built in</li>

                                </ul>
                        </td>
                </tr>
                 <tr>
                        <td>Ruby on Rails</td>
                        <td>

                                <ul>
                                        <li>Rich library of Gems</li>
                                        <li>Bundler is great for managing dependencies (similar to npm)</li>
                                        <li>Commands are very powerful (lots of stuff, for example, scaffolding can happen "automagically" with the right commands)</li>
                                        <li>Data migrations are well supported</li>

                                </ul>
                        </td>
                        <td>
                                <ul>
                                        <li>Learning the right commands to achieve the "magic" has a large learning curve</li>
                                         <li>Internals of "magic commands" can be difficult to understand</li>
                                         <li>Very large footprint</li>
                                        </li>Opinionated (for example, routing structure and ActiveRecord both make assumptions about your app's structure)</li>

                                </ul>
                        </td>
                </tr>
        </table>

        <h1>Hosting Services</h1>
        <p class="lead">Sosena</p>
        <table class="table table-responsive table-striped">
                <tr class="text-center">
                        <th>Name</th>
                        <th>Pros</th>
                        <th>Cons</th>
                </tr>
                <tr>
                        <td>Heroku</td>
                        <td>
                                <ul>
                                        <li>All members of the group are familiar with it.</li>
                                        <li>Documentation and support is good, won’t anticipate using its platform services that challenging</li>
                                        <li>You can deploy using git commands</li>
                                        <li>Free for the first DYNO (allows to run many kinds of app, simple API’s)</li>
                                        <li>Good for small Apps</li>
                                </ul>
                        </td>
                        <td>
                                <ul>
                                        <li>Limited control over architecture : Heroku just gives an environment where you just push your code </li>
                                        <li>You can’t increase RAM, storage or CPU performance
Additional storage must be hosted separately through another service.</li>
<li>Not the best option for large Apps (i.e requiring a larger database, bigger RAM).
</li>
                                </ul>
                        </td>
                </tr>
                <tr>
                        <td>Amazon Web Services</td>
                        <td>

                                <ul>
                                        <li>Flexibility in terms of the architecture: You can choose the best memory configuration , CPU and
                       And storage for your app
                                        </li>
                                        <li> Provides a reliable platform through its many data center groups around the world.</li>


                                </ul>
                        </td>
                        <td>
                                <ul>
                                        <li>You have to deploy your application yourself</li>
<li>You have to administer the system yourself.</li>
<li>Launching multiple app instances is not as easy with Heroku </li>

                                </ul>
                        </td>
                </tr>
        </table>

        <h1>Front-End Frameworks</h1>
        <p class="lead">Justin</p>
        <table class="table table-responsive table-striped">
                <tr class="text-center">
                        <th>Name</th>
                        <th>Pros</th>
                        <th>Cons</th>
                </tr>
                <tr>
                        <td>AngularJS</td>
                        <td>
                                <ul>
                                        <li>Justin and Leah are familiar with Angular 1</li>
                                        <li>Documentation and support for version 1 is extensive</li>
                                        <li>Reinforces Model-View-Controller (MVC) design pattern</li>
                                        <li>Allows for separation of concerns - can create services to communicate with REST api, controllers to pass that information onto the view</li>
                                        <li>Two-way data binding between client and server</li>
                                </ul>
                        </td>
                        <td>
                                <ul>
                                        <li>Somewhat bloated - way more than one might need in terms of functionality</li>
                                        <li> Learning curve is steeper than other libraries because there are custom directives and other syntactical idiosyncrasies</li>
                                </ul>
                        </td>
                </tr>
                <tr>
                        <td>React</td>
                        <td>

                                <ul>
                                        <li>Documentation seems comprehensive</li>
                                        <li>Easy to master</li>
                                        <li>Reinforces Model-View-Controller (MVC) design pattern</li>
                                        <li>Lightweight</li>

                                </ul>
                        </td>
                        <td>
                                <ul>
                                        <li>No one is familiar with React</li>
                                        <li>Frequent re-rendering may slow down the work of application at handling a large set of data.</li>
                                </ul>
                        </td>
                </tr>
        </table>
        <h1>Databases</h1>
        <p class="lead">Leah</p>
        <table class="table table-responsive table-striped">
                <tr class="text-center">
                        <th>Name</th>
                        <th>Pros</th>
                        <th>Cons</th>
                </tr>
                <tr>
                        <td>PostgreSQL</td>
                        <td>
                                <ul>
                                        <li>Third party tools and libraries can make PostgreSQL easier to use</li>
                                        <li>Programmable and therefore extensible with stored procedures.</li>
                                        <li>Capable of handling many tasks efficiently</li>
                                        <li>No read locks</li>
                                        <li>ACID compliant, data integrity maintained.  Multiple queries will return same output.</li>
                                </ul>
                        </td>
                        <td>
                                <ul>
                                        <li>Not great for read-heavy usage.  Because powerful, these types of operations can be slower. </li>
                                        <li>Not as popular as MySQL.  Might be harder to find support</li>
                                </ul>
                        </td>
                </tr>
                <tr>
                        <td>MySQL</td>
                        <td>

                                <ul>
                                        <li>Because MySQL is very popular, there are many third-party tools and integrated libraries</li>
                                        <li>Easy to learn</li>
                                        <li>Lots of security features</li>
                                        <li>Can handle lots of data</li>
                                        <li>Good read concurrency</li>

                                </ul>
                        </td>
                        <td>
                                <ul>
                                        <li>Not fully SQL compliant.  If we find that we need more SQL functionality, switching from MySQL to another relational database can be difficult.</li>
                                        <li>Although MySQL handles read concurrency well, read-write concurrency can be problematic. </li>
                                </ul>
                        </td>
                </tr>
        </table>

</div>
